<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Welcome to Natsun Blog~">
<meta property="og:type" content="website">
<meta property="og:title" content="Natsun Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Natsun Blog">
<meta property="og:description" content="Welcome to Natsun Blog~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Xya Fred">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>Natsun Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Natsun Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">留下记忆中的美好</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/08/HTML-CSS%E6%96%B0%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xya Fred">
      <meta itemprop="description" content="Welcome to Natsun Blog~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Natsun Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/HTML-CSS%E6%96%B0%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">HTML/CSS新特性</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 17:52:49" itemprop="dateCreated datePublished" datetime="2020-04-08T17:52:49+08:00">2020-04-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/07/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xya Fred">
      <meta itemprop="description" content="Welcome to Natsun Blog~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Natsun Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/07/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90/" class="post-title-link" itemprop="url">从输入URL到页面加载完成</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-07 21:55:25" itemprop="dateCreated datePublished" datetime="2020-04-07T21:55:25+08:00">2020-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-08 23:24:26" itemprop="dateModified" datetime="2020-04-08T23:24:26+08:00">2020-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第一步：DNS解析和DNS查询"><a href="#第一步：DNS解析和DNS查询" class="headerlink" title="第一步：DNS解析和DNS查询"></a>第一步：DNS解析和DNS查询</h3><p>这里是寻找IP地址的过程。查询的时候客户机到DNS是递归查询，DNS机到别的DNS机之间发生的是迭代查询。</p>
<p>首先是寻找DNS缓存：先浏览器，再找操作系统，</p>
<p>如果没有的话会进行分级查询：本地DNS服务器、根域名服务器，COM顶级域名服务器、google.com域名服务器（权威DNS服务器）</p>
<h3 id="第二步：TCP连接"><a href="#第二步：TCP连接" class="headerlink" title="第二步：TCP连接"></a>第二步：TCP连接</h3><p>（三次握手）=&gt; 为什么两次不可以</p>
<blockquote>
<p>seq：sequence序列号</p>
<p>Syn：Synchronization 同步</p>
<p>Ack：acknowledgement 答复</p>
</blockquote>
<h4 id="第一次握手：客户端-gt-服务端"><a href="#第一次握手：客户端-gt-服务端" class="headerlink" title="第一次握手：客户端 -&gt; 服务端"></a>第一次握手：客户端 -&gt; 服务端</h4><p><em>客户端有发送信息的能力</em></p>
<p>建立连接，发送SYN = 1，seq = n</p>
<h4 id="第二次握手：服务端-gt-客户端"><a href="#第二次握手：服务端-gt-客户端" class="headerlink" title="第二次握手：服务端 -&gt; 客户端"></a>第二次握手：服务端 -&gt; 客户端</h4><p><em>服务端有接收信息和发送信息的能力</em></p>
<p>表示收到请求，发送SYN = 1（服务端同意建立连接），ack =  n + 1（确认收到客户端信息），seq = x（同时发送服务端自己的序列号）</p>
<h4 id="第三次握手：客户端-gt-服务端"><a href="#第三次握手：客户端-gt-服务端" class="headerlink" title="第三次握手：客户端 - &gt; 服务端"></a>第三次握手：客户端 - &gt; 服务端</h4><p><em>客户端有接收信息的能力</em></p>
<p>确认收到回复，发送SYN = 0（开始发送信息），ack = x + 1（确认），seq = n + 1</p>
<h3 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h3><p>客户发送HTTP请求服务端发送报文</p>
<h3 id="服务端处理请求"><a href="#服务端处理请求" class="headerlink" title="服务端处理请求"></a>服务端处理请求</h3><p>服务端处理客户端请求并发送一个HTTP报文</p>
<h3 id="浏览器解析和渲染页面"><a href="#浏览器解析和渲染页面" class="headerlink" title="浏览器解析和渲染页面"></a>浏览器解析和渲染页面</h3><p>浏览器获得一个HTML文件，自上而下加载，下载和渲染同步进行，遇到CSS发送请求并行下载，图片则是异步请求，遇到js文件则挂起</p>
<p>（ html =&gt; dom树 ）+（ css =&gt; cssom ）= render渲染树（不渲染：head，display:none）</p>
<h3 id="连接结束"><a href="#连接结束" class="headerlink" title="连接结束"></a>连接结束</h3><p>（四次挥手）=&gt; 为什么三次不可以</p>
<blockquote>
<p>Fin：finish结束</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端 -&gt; 服务端:</span><br><span class="line">客户端 -&gt; 服务端:</span><br><span class="line">客户端 -&gt; 服务端:</span><br><span class="line">客户端 -&gt; 服务端:</span><br></pre></td></tr></table></figure>

<h4 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h4><p>客户端发送确认断开连接的请求</p>
<h4 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h4><h4 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h4><h4 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h4><p>发完了</p>
<p>知道发完了</p>
<p>收完了</p>
<p>知道收完了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/07/HTTP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xya Fred">
      <meta itemprop="description" content="Welcome to Natsun Blog~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Natsun Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/07/HTTP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">HTTP与HTTPS</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-07 15:58:09" itemprop="dateCreated datePublished" datetime="2020-04-07T15:58:09+08:00">2020-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-08 23:24:19" itemprop="dateModified" datetime="2020-04-08T23:24:19+08:00">2020-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="HTTP协议介绍"><a href="#HTTP协议介绍" class="headerlink" title="HTTP协议介绍"></a>HTTP协议介绍</h4><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。</p>
<p>HTTP是<strong>基于TCP/IP通信协议</strong>来传递数据（HTML 文件, 图片文件, 查询结果等）</p>
<p>HTTP是一个<strong>应用层协议</strong>，由<strong>请求和响应</strong>构成，是一个标准的客户端服务器模型。HTTP是一个<strong>无状态的协议</strong>。</p>
<h4 id="HTTP协议工作流程"><a href="#HTTP协议工作流程" class="headerlink" title="HTTP协议工作流程"></a>HTTP协议工作流程</h4><p>一个http操作称为一个事务，其工作流程大概如下：</p>
<ol>
<li>用户在浏览器中键入需要访问的网页URL</li>
<li>浏览器根据URL中的域名，通过DNS解析获得目标网页的IP地址</li>
<li>在HTTP开始工作前，客户端会通过<code>TCP/IP协议</code>和服务端建立连接（TCP三次握手</li>
<li>建立连接后，客户端会发送请求给服务端。</li>
<li>服务器接到请求后，给予相应的响应信息。</li>
<li>Web服务器向浏览器发送了请求数据后，关闭TCP连接。（如果浏览器或者服务器在其头信息加入了<code>Connection:keep-alive</code>，TCP连接在发送后会仍然保持打开状态。</li>
</ol>
<h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><p>客户端发送HTTP请求到服务器的请求消息格式包括有：</p>
<p><strong>请求行</strong>（request line）、<strong>请求头</strong>（header）和<strong>请求正文</strong></p>
<ul>
<li>状态行：包括请求方式Method、资源路径URL、协议版本Version；</li>
<li>请求头：包括一些访问的域名、用户代理、Cookie等信息；</li>
<li>请求正文：就是HTTP请求的数据。</li>
</ul>
<h4 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h4><p>HTTP响应由三个部分组成，分别是：<strong>状态行</strong>、<strong>响应头</strong>和<strong>响应正文</strong>。</p>
<ul>
<li>状态行：包括协议版本Version、状态码Status Code、回应短语；</li>
<li>响应头：包括搭建服务器的软件，发送响应的时间，回应数据的格式等信息；</li>
<li>响应正文：就是响应的具体数据。</li>
</ul>
<hr>
<h3 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h3><h4 id="HTTPS是什么？"><a href="#HTTPS是什么？" class="headerlink" title="HTTPS是什么？"></a>HTTPS是什么？</h4><blockquote>
<p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但<strong>利用SSL/TLS来加密数据包</strong>。HTTPS开发的主要目的，是<strong>提供对网站服务器的身份认证</strong>，保护交换数据的隐私与完整性</p>
</blockquote>
<h4 id="TLS、SSL又是什么？"><a href="#TLS、SSL又是什么？" class="headerlink" title="TLS、SSL又是什么？"></a>TLS、SSL又是什么？</h4><blockquote>
<p><strong>传输层安全性协议</strong>（英语：Transport Layer Security，缩写作 <strong>TLS</strong>），及其前身<strong>安全套接层</strong>（Secure Sockets Layer，缩写作 <strong>SSL</strong>）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。</p>
</blockquote>
<p>TLS/SSL 的功能实现主要依赖于三类基本算法：<strong>散列函数</strong>、<strong>对称加密</strong>和<strong>非对称加密</strong>，其利用非对称加密实现<strong>身份认证和密钥协商</strong>，对称加密算法采用<strong>协商的密钥对数据加密</strong>，基于散列函数<strong>验证信息的完整性</strong>。</p>
<h4 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h4><ol>
<li>客户端往服务器的443端口发起请求。</li>
<li>服务器收到请求，将数字证书返回给浏览器（数字证书可以是CA颁布的，也可以是自制的，自制的需要客户端验证通过才可继续访问）</li>
<li>客户端解析证书（由浏览器内置TLS完成）<ol>
<li>首先浏览器先从内置的证书列表中索引，找到服务器下发证书的机构</li>
<li>用机构的证书公钥解密得到证书的内容（包括网站的网址、网站的公钥、证书有效期等），验证数字签名的合法性。</li>
<li>验证后，会生成一个随机值R，用证书公钥对该值进行加密再传给服务端，以后客户端和服务端就可通过该随机值R进行通信了。</li>
</ol>
</li>
<li>服务端通过私钥解密信息。服务端获得该随机值R后，把内容通过该值R与对称加密算法进行加密传输给客户端。</li>
<li>客户端通过之前生成的随机值R解密服务端传来的加密信息。</li>
</ol>
<h4 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h4><ul>
<li><strong>SEO方面</strong></li>
</ul>
<p>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p>
<ul>
<li><strong>安全性</strong></li>
</ul>
<ol>
<li>使用HTTPS协议<strong>可认证用户和服务器</strong>，确保数据发送到正确的客户机和服务器；</li>
<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可<strong>防止数据在传输过程中不被窃取、改变，确保数据的完整性</strong>。</li>
<li>HTTPS是现行架构下最安全的解决方案，大幅<strong>增加了中间人攻击的成本</strong>。</li>
</ol>
<h4 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h4><ul>
<li>SSL证书要钱，越是功能强大的证书费用越高</li>
<li>HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。</li>
<li>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本。</li>
<li>HTTPS协议握手阶段比较费时，网站的响应速度相比HTTP较慢。</li>
</ul>
<hr>
<h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><ol>
<li>http传输的数据都是未加密的，也就是明文的；https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高</li>
<li>一般而言，http协议的端口为80，https的端口为443 </li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 </li>
</ol>
<h3 id="强缓存和弱缓存"><a href="#强缓存和弱缓存" class="headerlink" title="强缓存和弱缓存"></a>强缓存和弱缓存</h3><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>1XX：信息状态码</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>继续</td>
<td>初始请求已接受，请客户端继续发送剩余部分</td>
</tr>
<tr>
<td>101</td>
<td>切换协议</td>
<td>服务器根据客户端的请求切换协议。</td>
</tr>
</tbody></table>
<p>2XX：成功状态码</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>200</strong></td>
<td><strong>成功</strong></td>
<td><strong>服务器已成功处理请求</strong></td>
</tr>
<tr>
<td>201</td>
<td>已创建</td>
<td>请求成功并且服务器创建了新的资源</td>
</tr>
<tr>
<td>202</td>
<td>已接受</td>
<td>服务器已接受请求但尚未处理</td>
</tr>
<tr>
<td>203</td>
<td>非授权信息</td>
<td>服务器已成功处理请求，但返回的信息可能来自另一个来源</td>
</tr>
<tr>
<td>204</td>
<td>无内容</td>
<td>服务器已成功处理请求，但没返回任何内容</td>
</tr>
<tr>
<td>205</td>
<td>重置内容</td>
<td>服务器处理成功，用户终端应重置文档视图</td>
</tr>
<tr>
<td>206</td>
<td>部分内容</td>
<td>服务器成功处理了部分GET请求</td>
</tr>
</tbody></table>
<p>3XX：重定向状态码</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>300</td>
<td>多种选择</td>
<td>针对请求，服务器可以执行多种操作</td>
</tr>
<tr>
<td>301</td>
<td>永久移动</td>
<td>请求的页面已永久跳转到新的url</td>
</tr>
<tr>
<td>302</td>
<td>临时移动</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>303</td>
<td>查看其他位置</td>
<td>查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td><strong>304</strong></td>
<td>未修改</td>
<td>自从上次请求后，请求的网页未修改过。<strong>请求被重定向到客户端本地缓存</strong></td>
</tr>
<tr>
<td>305</td>
<td>使用代理</td>
<td>请求者只能使用代理访问请求的网页</td>
</tr>
<tr>
<td>307</td>
<td>临时重定向</td>
<td>临时重定向。与302类似。使用GET请求重定向</td>
</tr>
</tbody></table>
<p>4XX：客户端错误状态码</p>
<table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>含义</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>400</strong></td>
<td><strong>错误请求</strong></td>
<td><strong>服务器不理解请求的语法</strong></td>
</tr>
<tr>
<td><strong>401</strong></td>
<td><strong>未授权</strong></td>
<td><strong>请求要求用户的身份验证</strong></td>
</tr>
<tr>
<td><strong>403</strong></td>
<td><strong>禁止</strong></td>
<td><strong>服务器拒绝请求</strong></td>
</tr>
<tr>
<td><strong>404</strong></td>
<td><strong>未找到</strong></td>
<td><strong>服务器找不到请求的页面</strong></td>
</tr>
<tr>
<td><strong>405</strong></td>
<td><strong>方法禁用</strong></td>
<td><strong>禁用请求中指定的方法</strong></td>
</tr>
<tr>
<td>406</td>
<td>不接受</td>
<td>无法使用请求的内容特性响应请求的页面</td>
</tr>
<tr>
<td>407</td>
<td>需要代理授权</td>
<td>请求需要代理的身份认证</td>
</tr>
<tr>
<td>408</td>
<td>请求超时</td>
<td>服务器等候请求时发生超时</td>
</tr>
<tr>
<td>409</td>
<td>冲突</td>
<td>服务器在完成请求时发生冲突</td>
</tr>
<tr>
<td>410</td>
<td>已删除</td>
<td>客户端请求的资源已经不存在</td>
</tr>
<tr>
<td>411</td>
<td>需要有效长度</td>
<td>服务器不接受不含有效长度表头字段的请求</td>
</tr>
<tr>
<td>412</td>
<td>未满足前提条件</td>
<td>服务器未满足请求者在请求中设置的其中一个前提条件</td>
</tr>
<tr>
<td>413</td>
<td>请求实体过大</td>
<td>由于请求实体过大，服务器无法处理，因此拒绝请求</td>
</tr>
<tr>
<td>414</td>
<td>请求url过长</td>
<td>请求的url过长，服务器无法处理</td>
</tr>
<tr>
<td>415</td>
<td>不支持格式</td>
<td>服务器无法处理请求中附带媒体格式</td>
</tr>
<tr>
<td>416</td>
<td>范围无效</td>
<td>客户端请求的范围无效</td>
</tr>
<tr>
<td>417</td>
<td>未满足期望</td>
<td>服务器无法满足请求表头字段要求</td>
</tr>
</tbody></table>
<p>5XX：服务端错误状态码</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>500</strong></td>
<td><strong>服务器错误</strong></td>
<td><strong>服务器内部错误，无法完成请求</strong></td>
</tr>
<tr>
<td>501</td>
<td>尚未实施</td>
<td>服务器不具备完成请求的功能</td>
</tr>
<tr>
<td>502</td>
<td>错误网关</td>
<td>服务器作为网关或代理出现错误</td>
</tr>
<tr>
<td><strong>503</strong></td>
<td><strong>服务不可用</strong></td>
<td><strong>服务器目前无法使用</strong></td>
</tr>
<tr>
<td>504</td>
<td>网关超时</td>
<td>网关或代理服务器，未及时获取请求</td>
</tr>
<tr>
<td>505</td>
<td>不支持版本</td>
<td>服务器不支持请求中使用的HTTP协议版本</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/07/JSONP%E4%B8%8EAJAX%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xya Fred">
      <meta itemprop="description" content="Welcome to Natsun Blog~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Natsun Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/07/JSONP%E4%B8%8EAJAX%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">JSONP与AJAX实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-07 12:24:52" itemprop="dateCreated datePublished" datetime="2020-04-07T12:24:52+08:00">2020-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-08 14:18:09" itemprop="dateModified" datetime="2020-04-08T14:18:09+08:00">2020-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><h4 id="原理与实现步骤"><a href="#原理与实现步骤" class="headerlink" title="原理与实现步骤"></a>原理与实现步骤</h4><blockquote>
<p>我们可知跨域问题的实现方式有多种，其中一种便是通过HTML标签实现跨域（如<code>&lt;img&gt; &lt;link&gt; &lt;script&gt;</code>），JSONP便是通过script标签这一特性实现的。</p>
</blockquote>
<p>（一）声明一个回调函数，其函数值作为参数值，要传递给跨域请求数据的服务器，函数的形式参数为服务器返回的数据。</p>
<p>（二）创建一个script标签，把那个跨域的API数据接口地址，赋值给script的src，还要在这个地址中向服务器传递该函数名。通常使用<code>?</code>传递参数。</p>
<p>（三）服务器接收请求，对数据进行拼接处理。</p>
<p>（四）服务器通过HTTP协议把数据返回给客户端，客户端再调用之前的回调函数。</p>
<h4 id="JSONP的实现"><a href="#JSONP的实现" class="headerlink" title="JSONP的实现"></a>JSONP的实现</h4><p>首先实现一个最简单的JSONP：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function jsonp(url)&#123;</span><br><span class="line">		const script &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">		script.src &#x3D; url;</span><br><span class="line">		script.type &#x3D; &quot;type&#x2F;javascript&quot;;</span><br><span class="line">		document.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上只是最基本的写法，要是想要使用需要定义全局的回调函数，还需进行改进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function jsonp(&#123;url, params, callback&#125;)&#123;</span><br><span class="line">		window[callback] &#x3D;  callback;</span><br><span class="line">		const script &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">		let arr &#x3D; [];</span><br><span class="line">		params &#x3D; &#123;...params, callback&#125;;</span><br><span class="line">		for(var key in params)&#123;</span><br><span class="line">				arr.push(&#96;$&#123;url&#125;&#x3D;$&#123;params[key]&#125;&#96;);</span><br><span class="line">		&#125;</span><br><span class="line">		script.src &#x3D; &#96;$&#123;url&#125;?$&#123;arr.join(&#39;&amp;&#39;)&#125;&#96;;</span><br><span class="line">		script.type &#x3D; &quot;type&#x2F;javascript&quot;;</span><br><span class="line">		document.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个函数改进了不足，但依旧存在不足之处：</p>
<p>（1）没清楚生成的script标签</p>
<p>（2）要写回调，很麻烦</p>
<p>因此下面使用ES6的promise语法进行改进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function jsonp(&#123;url, params, callback&#125;)&#123;</span><br><span class="line">		return new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">				let script &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">				window[callback] &#x3D; (data) &#x3D;&gt; &#123;</span><br><span class="line">						resolve(data);</span><br><span class="line">						&#x2F;&#x2F; 删除了script标签，原因应该是考虑同网页函数反复调用问题</span><br><span class="line">						document.body.removeChild(script);	</span><br><span class="line">				&#125;</span><br><span class="line">				params &#x3D; &#123; ...params, callback &#125;;</span><br><span class="line">				let arrs &#x3D; [];</span><br><span class="line">				for(var key in params)&#123;</span><br><span class="line">						arr.push(&#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;);</span><br><span class="line">				&#125;</span><br><span class="line">				script.src &#x3D; &#96;$&#123;url&#125;?$&#123;arr.join(&#39;&amp;&#39;)&#125;&#96;;</span><br><span class="line">				script.type &#x3D; &quot;type&#x2F;javascript&quot;;</span><br><span class="line">				document.body.appendChild(script);</span><br><span class="line">		&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; test demo:</span><br><span class="line">jsonp(&#123;</span><br><span class="line">		url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;&#39;,</span><br><span class="line">		params: &#123;test:&quot;test&quot;&#125;,</span><br><span class="line">		callback: &quot;show&quot;</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">		console.log(data);</span><br><span class="line">&#125;).catch((e) &#x3D;&gt; &#123;console.err(e)&#125;)</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="AJAX的实现方法"><a href="#AJAX的实现方法" class="headerlink" title="AJAX的实现方法"></a>AJAX的实现方法</h3><h4 id="JQuery提供的AJAX方法："><a href="#JQuery提供的AJAX方法：" class="headerlink" title="JQuery提供的AJAX方法："></a>JQuery提供的AJAX方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">		url: &quot;&quot;,</span><br><span class="line">		type: &quot;&quot;,</span><br><span class="line">		dataType: &quot;&quot;,</span><br><span class="line">		data: &#123;</span><br><span class="line">				</span><br><span class="line">		&#125;,</span><br><span class="line">		success: function()&#123;&#125;,</span><br><span class="line">		error: function()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><blockquote>
<p><code>XMLHttpRequest</code> 对象</p>
</blockquote>
<p>用于在后台与服务器交换数据</p>
<blockquote>
<p><code>xmlhttp.open(method,url,async)</code></p>
</blockquote>
<ul>
<li><p>method：请求类型（GET，POST）</p>
</li>
<li><p>url：文件在服务器上的位置</p>
</li>
<li><p>async：true（异步）或false（同步）</p>
</li>
</ul>
<blockquote>
<p><code>xmlhttp.onreadystatechang事件</code></p>
</blockquote>
<ul>
<li>当请求被发送到服务器时，我们需要执行一些基于响应的任务</li>
<li>每当readyState改变时，就会触发该事件</li>
<li>readyState属性存有XMLHTTPRequest的状态信息</li>
</ul>
<blockquote>
<p><code>xmlhttp.readyState</code>状态码</p>
</blockquote>
<ul>
<li>0：请求未初始化</li>
<li>1：服务器连接已建立</li>
<li>2：请求已接受</li>
<li>3：请求处理中</li>
<li>4：请求已完成，且响应已就绪</li>
</ul>
<blockquote>
<p><code>xmlhttp.status</code>即HTTP状态码</p>
</blockquote>
<h4 id="原生js实现AJAX方法："><a href="#原生js实现AJAX方法：" class="headerlink" title="原生js实现AJAX方法："></a>原生js实现AJAX方法：</h4><p>（1）创建一个异步对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (window.XMLHttpRequest)</span><br><span class="line">&#123;		&#x2F;&#x2F; code for IE7+, Firefox, Chrome, Opera, Safari</span><br><span class="line">		xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;		&#x2F;&#x2F; code for IE6, IE5</span><br><span class="line">		mlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）打开连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;, url, true);</span><br></pre></td></tr></table></figure>

<p>（3）发送请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET 请求:</span><br><span class="line">xmlhttp.send();&#x2F;&#x2F;get请求的参数加在url的后面</span><br><span class="line"></span><br><span class="line">POST 请求:</span><br><span class="line">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application&#x2F;x-www-form-urlencoded&quot;);    &#x2F;&#x2F; 向请求添加HTTP头</span><br><span class="line">xmlhttp.send(&quot;fname&#x3D;Bill&amp;lname&#x3D;Gates&quot;);	&#x2F;&#x2F;post请求的参数要放在send()里面</span><br></pre></td></tr></table></figure>

<p>（4）监听状态变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.onreadystatechange &#x3D; function (ev2) &#123;</span><br><span class="line">		if(xmlhttp.readyState &#x3D;&#x3D;&#x3D; 4)&#123;</span><br><span class="line">				&#x2F;&#x2F; 判断是否请求成功</span><br><span class="line">				if(xmlhttp.status &gt;&#x3D; 200 &amp;&amp; xmlhttp.status &lt; 300 ||xmlhttp.status &#x3D;&#x3D;&#x3D; 304)&#123;</span><br><span class="line">						&#x2F;&#x2F; 处理返回的结果</span><br><span class="line">						console.log(&quot;接收到服务器返回的数据&quot;);</span><br><span class="line">						success(xmlhttp);</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">						console.log(&quot;没有接收到服务器返回的数据&quot;);</span><br><span class="line">						error(xmlhttp);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="封装ajax方法"><a href="#封装ajax方法" class="headerlink" title="封装ajax方法"></a>封装ajax方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var myAjax &#x3D; &#123;</span><br><span class="line">    get: function (url, fn) &#123;</span><br><span class="line">        var xmlhttp &#x3D; new XMLHttpRequest();</span><br><span class="line">        xmlhttp.open(&quot;GET&quot;, url, true);</span><br><span class="line">        xmlhttp.send();</span><br><span class="line">        xmlhttp.onreadystatechange &#x3D; function (e) &#123;</span><br><span class="line">            if(xmlhttp.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; xmlhttp.status &#x3D;&#x3D;&#x3D; 200 || xmlhttp.status &#x3D;&#x3D;&#x3D; 304)&#123;</span><br><span class="line">                &#x2F;&#x2F; xmlhttp.responseText为从服务端返回的数据</span><br><span class="line">                fn.call(this, xmlhttp.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    post: function (url, fn, data) &#123;</span><br><span class="line">        var xmlhttp &#x3D; new XMLHttpRequest();</span><br><span class="line">        xmlhttp.open(&quot;POST&quot;, url, true);</span><br><span class="line">        &#x2F;&#x2F; 添加http头，发送信息至服务器时内容编码类型</span><br><span class="line">        xmlhttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;x-www-form-urlencoded&quot;);</span><br><span class="line">        xmlhttp.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">            if(xmlhttp.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; xmlhttp.status &#x3D;&#x3D;&#x3D; 200 || xmlhttp.status &#x3D;&#x3D;&#x3D; 304)&#123;</span><br><span class="line">                fn.call(this, xmlhttp.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xmlhttp.send(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/06/JS%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xya Fred">
      <meta itemprop="description" content="Welcome to Natsun Blog~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Natsun Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/JS%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">JS跨域问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 16:06:27" itemprop="dateCreated datePublished" datetime="2020-04-06T16:06:27+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-08 14:17:55" itemprop="dateModified" datetime="2020-04-08T14:17:55+08:00">2020-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>所谓的  <strong>同源</strong>  是指<strong>域名、协议、端口号</strong> 相同。不同的客户端脚本（javascript，ActionScript）在没有授权的情况下，不能读取对方资源。简单来说，浏览器允许包含在页面A的脚本访问第二个页面B的数据资源，这一切是建立在A和B页面是同源的基础上。</p>
<blockquote>
<p>同源策略 是由Netscape提出的一个著名的安全策略，现在所有支持JavaScript 的浏览器都会使用这个策略。实际上，这种策略只是一个规范，并不是强制要求，各大厂商的浏览器只是针对同源策略的一种实现。它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。</p>
</blockquote>
<h4 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h4><p>跨域就是<strong>从一个域名的网页去请求另一个域名的资源</strong>。比如从<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 页面去请求 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 的资源,出于安全方面的考虑，页面中的JavaScript在<strong>请求非同源的资源</strong>时就会出 <strong>跨域问题</strong> ，这时，由于同源策略，我们的请求会被浏览器禁止。</p>
<p><img src="http://q76oz3v1b.bkt.clouddn.com/JS%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E4%BE%8B%E5%AD%90.png" alt="跨域问题例子"></p>
<p>浏览器执行JavaScript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。</p>
<h4 id="为什么要跨域？"><a href="#为什么要跨域？" class="headerlink" title="为什么要跨域？"></a>为什么要跨域？</h4><p>最主要的原因便是<strong>安全问题</strong>：如果一个网页可以随意访问另一个网页的资源，那么就有可能在客户完全不知情的情况下出现安全问题。举个例子</p>
<ol>
<li>用户访问银行账户，登陆网银进行操作，登陆的信息通过cookie保存在了浏览器</li>
<li>用户不小心访问了一个钓鱼网站</li>
<li>钓鱼网站执行脚本，在浏览器页面拿到了银行和cookie，比如用户、登陆token等</li>
<li>如果此时浏览器不予限制，并且银行没有安全处理，那么用户的信息便可能会泄露</li>
</ol>
<hr>
<h3 id="解决跨域问题的方法"><a href="#解决跨域问题的方法" class="headerlink" title="解决跨域问题的方法"></a>解决跨域问题的方法</h3><h4 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h4><blockquote>
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器如何沟通。CORS背后的基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>
</blockquote>
<p>服务器端对于CORS的支持，主要是通过设置Accesss-Control-Allow-Origin来进行。如果浏览器检测到相应设置，就允许AJAX进行跨域访问。</p>
<p>只需要在后台中加上<strong>响应头来允许域请求</strong>！在被请求的Response header中加入以下设置，就可以实现Ajax跨域访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 指定允许其他域名访问</span><br><span class="line">&#39;Access-Control-Allow-Origin: *&#39;	&#x2F;&#x2F; 或指定其他域</span><br><span class="line">&#x2F;&#x2F; 响应类型</span><br><span class="line">&#39;Access-Control-Allow-Methods: GET,POST&#39;</span><br><span class="line">&#x2F;&#x2F; 响应头设置</span><br><span class="line">&#39;Access-Control-Allow-Headers: x-request-with,content-type&#39;</span><br></pre></td></tr></table></figure>



<h4 id="通过JSONP跨域"><a href="#通过JSONP跨域" class="headerlink" title="通过JSONP跨域"></a>通过JSONP跨域</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>JSONP是JSON with Padding的缩写，是应用JSON的一种新方法，只不过是<strong>被包含在函数调用中的json</strong>。JSONP由两个部分组成：<strong>回调函数</strong>和<strong>数据</strong>。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>通过script标签引入异步加载的js文件，当js文件加载成功后会调用url参数中的回调函数，并会把我们需要的数据作为参数传入。即<strong>用JavaScript动态加载一个js文件，同时定义一个回调函数给script执行</strong>。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是<a href="http://example.com/data.php,那么a.html中的代码就可以这样：" target="_blank" rel="noopener">http://example.com/data.php,那么a.html中的代码就可以这样：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">		function dosomething(jsondata)&#123;</span><br><span class="line">        &#x2F;&#x2F;处理获得的json数据</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;data.php?callback&#x3D;dosomething&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要<strong>服务器端的页面</strong>进行相应的配合的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$callback &#x3D; $_GET[&#39;callback&#39;];&#x2F;&#x2F;得到回调函数名</span><br><span class="line">$data &#x3D; array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);&#x2F;&#x2F;要返回的数据</span><br><span class="line">echo $callback.&#39;(&#39;.json_encode($data).&#39;)&#39;;&#x2F;&#x2F;输出</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>最终，输出结果为：<code>dosomething([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]);</code></p>
<h5 id="JSONP的优缺点"><a href="#JSONP的优缺点" class="headerlink" title="JSONP的优缺点"></a>JSONP的优缺点</h5><ul>
<li>优点：不受同源策略的限制；兼容性更好；在更古老的浏览器中可以运行，不需要<code>XMLHTTPRequest</code>或者<code>ActiveX</code>的支持；请求完毕后可以通过调用callback的方式回传结果。</li>
<li>缺点：只<strong>支持GET请求</strong>而不支持POST等其他类型的请求；只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
</ul>
<h5 id="CORS和JSONP对比"><a href="#CORS和JSONP对比" class="headerlink" title="CORS和JSONP对比"></a>CORS和JSONP对比</h5><p>CORS与JSONP相比，无疑更为先进、方便和可靠。</p>
<ol>
<li><p>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求</p>
</li>
<li><p>使用CORS，开发者可以使用普通的XMLHTTPRequest发起请求和获得数据，比起JSONP有更好的错误处理。</p>
</li>
</ol>
<h4 id="通过修改document-domain来跨子域"><a href="#通过修改document-domain来跨子域" class="headerlink" title="通过修改document.domain来跨子域"></a>通过修改<code>document.domain</code>来跨子域</h4><p>浏览器的同源策略使得我们<strong>不能通过AJAX的方法</strong>去请求不同源中的文档，而且限制了浏览器中<strong>不同域的框架之间是不能进行js的交互操作</strong>的。</p>
<p><strong>不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。</strong>比如，有一个页面，它的地址是<code>http://www.example.com/a.html</code> ， 在这个页面里面有一个<code>iframe</code>，它的src是<code>http://example.com/b.html</code>, 很显然，这个页面与它里面的<code>iframe</code>框架是不同域的，所以我们是无法通过在页面中书写js代码来获取<code>iframe</code>中的东西的。</p>
<p>通过修改<code>document.domain</code>将域名设置成自身或更高一级的父域，且主域必须相同。</p>
<ol>
<li>在页面 <code>http://www.example.com/a.html</code> 中设置<code>document.domain</code>:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id &#x3D; &quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;b.html&quot; onload &#x3D; &quot;test()&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    document.domain &#x3D; &#39;example.com&#39;;	&#x2F;&#x2F;设置成主域</span><br><span class="line">    function test()&#123;</span><br><span class="line">    		&#x2F;&#x2F;contentWindow 可取得子窗口的 window 对象</span><br><span class="line">        alert(document.getElementById(&#39;￼iframe&#39;).contentWindow); </span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在页面 <code>http://example.com/b.html</code> 中也设置<code>document.domain</code>:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">		&#x2F;&#x2F;在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同</span><br><span class="line">    document.domain &#x3D; &#39;example.com&#39;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="使用window-name来进行跨域"><a href="#使用window-name来进行跨域" class="headerlink" title="使用window.name来进行跨域"></a>使用<code>window.name</code>来进行跨域</h4><p>window对象有一个name属性，该属性有一个特征：<strong>即在一个窗口的生命周期内，窗口载入的所有页面都是共享一个<code>window.name</code>的，每个页面对<code>window.name</code>都有读写权限</strong>，<code>window.name</code>是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p>
<p>注意，<code>window.name</code>的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器。</p>
<h4 id="使用HTML5的window-postMessage实现跨域"><a href="#使用HTML5的window-postMessage实现跨域" class="headerlink" title="使用HTML5的window.postMessage实现跨域"></a>使用HTML5的<code>window.postMessage</code>实现跨域</h4><p><code>**window.postMessage**(message,targetOrigin)</code>  方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。</p>
<p>调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 *  </p>
<p>需要接收消息的window对象，可是通过<strong>监听自身的message事件</strong>来获取传过来的消息，消息内容<strong>储存在该事件对象的data属性</strong>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这是 http:&#x2F;&#x2F;test.com&#x2F;a.html 的代码 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function onLoad()&#123;</span><br><span class="line">		var iframe &#x3D; document.getELementById(&#39;iframe&#39;);</span><br><span class="line">		var win &#x3D; iframe.contentWindow;		&#x2F;&#x2F; 获取window对象</span><br><span class="line">		win.postMessage(&quot;俺是来自页面a的消息！&quot;,&quot;*&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;iframe id&#x3D;&quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;test.com&#x2F;b.html&quot; onload&#x3D;&quot;onLoad()&quot;&gt;&lt;&#x2F;iframe&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这是 http:&#x2F;&#x2F;test.com&#x2F;b.html 的代码 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.onmessage &#x3D; function(e)&#123;</span><br><span class="line">		var e &#x3D; e || event;</span><br><span class="line">		alert(e.data);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="web-sockets"><a href="#web-sockets" class="headerlink" title="web sockets"></a>web sockets</h4><p>web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)</p>
<p>web sockets原理：在js创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web socket协议。</p>
<p>只有在支持web socket协议的服务器上才能正常工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;http-&gt;ws;  https-&gt;wss</span><br><span class="line">var socket &#x3D; new WebSockt(&#39;ws:&#x2F;&#x2F;www.baidu.com&#39;);</span><br><span class="line">socket.send(&#39;hello WebSockt&#39;);</span><br><span class="line">socket.onmessage &#x3D; function(event)&#123;</span><br><span class="line">    var data &#x3D; event.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="XSS和CRSF攻击"><a href="#XSS和CRSF攻击" class="headerlink" title="XSS和CRSF攻击"></a>XSS和CRSF攻击</h3><h4 id="XSS跨站脚本攻击（代码注入的一种）"><a href="#XSS跨站脚本攻击（代码注入的一种）" class="headerlink" title="XSS跨站脚本攻击（代码注入的一种）"></a>XSS跨站脚本攻击（代码注入的一种）</h4><p> XSS, 即为（Cross Site Scripting）, 中文名为跨站脚本,  是发生在目标用户的浏览器层面上的，当渲染DOM树的过程成发生了不在预期内执行的JS代码时，就发生了XSS攻击。</p>
<p>攻击者可以使用户在浏览器中<strong>执行其预定义的恶意脚本</strong>，实际上是在目标网站的作用域下执行了这段js代码，其导致的危害可想而知，如劫持用户会话，插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖<a href="https://baike.baidu.com/item/XSS蠕虫/22777013" target="_blank" rel="noopener">XSS蠕虫</a>，甚至破坏网站、修改路由器配置信息等。</p>
<h4 id="XSS防御措施"><a href="#XSS防御措施" class="headerlink" title="XSS防御措施"></a>XSS防御措施</h4><p>XSS防御的总体思路是：</p>
<ul>
<li><p>在不需要HTML输入的地方对HTML标签及一些特殊字符进行过滤，将其转化为不被浏览器解析执行的字符。 </p>
</li>
<li><p>对输入(和URL参数)进行过滤，对输出进行编码。也就是对提交的所有内容进行过滤，对url中的参数进行过滤，过滤掉会导致脚本执行的相关内容；</p>
</li>
</ul>
<h4 id="CSRF跨站请求伪造"><a href="#CSRF跨站请求伪造" class="headerlink" title="CSRF跨站请求伪造"></a>CSRF跨站请求伪造</h4><p>CSRF（Cross Site Request  Forgery，跨站请求伪造），字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie  还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。 </p>
<h4 id="CSRF防御措施"><a href="#CSRF防御措施" class="headerlink" title="CSRF防御措施"></a>CSRF防御措施</h4><p>防御CSRF 攻击主要有三种策略：</p>
<ul>
<li>验证 HTTP Referer 字段；</li>
<li>在请求地址中添加 token 并验证；</li>
<li>在 HTTP 头中自定义属性并验证。 </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/04/JS%E5%BC%82%E6%AD%A5Promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xya Fred">
      <meta itemprop="description" content="Welcome to Natsun Blog~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Natsun Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/04/JS%E5%BC%82%E6%AD%A5Promise/" class="post-title-link" itemprop="url">JS异步Promise</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-04 23:22:49" itemprop="dateCreated datePublished" datetime="2020-04-04T23:22:49+08:00">2020-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-05 14:37:39" itemprop="dateModified" datetime="2020-04-05T14:37:39+08:00">2020-04-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 手写实现Promise</span><br><span class="line"> * **&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建了三个常量用于表示状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">var myPromise &#x3D; function (fn) &#123;</span><br><span class="line">    console.log(&quot;Create a Promise!&quot;);</span><br><span class="line">    let _this &#x3D; this;</span><br><span class="line">    _this.state &#x3D; PENDING;</span><br><span class="line">    _this.value &#x3D; null;</span><br><span class="line">    _this.rejectedCallBacks &#x3D; [];</span><br><span class="line">    _this.resolvedCallBacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 首先两个函数都得判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态</span><br><span class="line">    &#x2F;&#x2F; 将当前状态更改为对应状态，并且将传入的值赋值给 value</span><br><span class="line">    &#x2F;&#x2F; vaule值会做为Promise的参数被后续调用&lt;promise&gt;</span><br><span class="line">    &#x2F;&#x2F; 遍历回调数组并执行</span><br><span class="line">    function resolve(value) &#123;</span><br><span class="line">        console.log(&quot;Running Resolve&quot;);</span><br><span class="line">        if(_this.state &#x3D;&#x3D;&#x3D; PENDING)&#123;</span><br><span class="line">            _this.state &#x3D; FULFILLED;</span><br><span class="line">            _this.value &#x3D; value;</span><br><span class="line">            _this.resolvedCallBacks.map(cb &#x3D;&gt; cb(_this.value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(value) &#123;</span><br><span class="line">        console.log(&quot;Running Reject&quot;);</span><br><span class="line">        if(_this.state &#x3D;&#x3D;&#x3D; PENDING)&#123;</span><br><span class="line">            _this.state &#x3D; REJECTED;</span><br><span class="line">            _this.value &#x3D; value;</span><br><span class="line">            _this.rejectedCallBacks.map(cb &#x3D;&gt; cb(_this.value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 实现很简单，执行传入的参数并且将之前两个函数当做参数传进去</span><br><span class="line">    &#x2F;&#x2F; 要注意的是，可能执行函数过程中会遇到错误，需要捕获错误并且执行 reject 函数</span><br><span class="line">    try &#123;</span><br><span class="line">        console.log(&quot;Running try &amp; catch&quot;);</span><br><span class="line">        fn(resolve, reject);</span><br><span class="line">    &#125;catch (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; prototype实现then方法</span><br><span class="line">myPromise.prototype.then &#x3D; function (onFulfilled, onRejected) &#123;</span><br><span class="line">    const _this &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span><br><span class="line">    &#x2F;&#x2F; 当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传</span><br><span class="line">    onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39;? onFulfilled: v &#x3D;&gt; v;</span><br><span class="line">    onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39;? onRejected: err &#x3D;&gt; &#123;throw err&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据状态执行相应函数</span><br><span class="line">    &#x2F;&#x2F; 如果状态是等待态的话，就往回调函数中 push 函数</span><br><span class="line">    if(_this.state &#x3D;&#x3D;&#x3D; PENDING)&#123;</span><br><span class="line">        _this.resolvedCallBacks.push(onFulfilled);</span><br><span class="line">        _this.rejectedCallBacks.push(onRejected);</span><br><span class="line">    &#125;else if(_this.state &#x3D;&#x3D;&#x3D; FULFILLED)&#123;</span><br><span class="line">        onFulfilled(_this.value);</span><br><span class="line">    &#125;else if(_this.state &#x3D;&#x3D;&#x3D; REJECTED)&#123;</span><br><span class="line">        onRejected(_this.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 测试DEMO</span><br><span class="line">new myPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        resolve(&quot;Write your content here!!&quot;)</span><br><span class="line">        &#x2F;&#x2F;reject(&quot;can i reject?&quot;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    console.log(&quot;This is my Then&quot;);</span><br><span class="line">&#125;, err&#x3D;&gt;&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/04/JS%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xya Fred">
      <meta itemprop="description" content="Welcome to Natsun Blog~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Natsun Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/04/JS%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">JS常见的几个函数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-04 12:30:26" itemprop="dateCreated datePublished" datetime="2020-04-04T12:30:26+08:00">2020-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-08 15:31:41" itemprop="dateModified" datetime="2020-04-08T15:31:41+08:00">2020-04-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>日常开发过程中，滚动事件频繁调用回调函数很可能造成页面卡顿，这时候就需要防抖<code>debounce</code>和节流<code>throttle</code>来对代码进行性能优化了！</p>
<h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><p>当<strong>持续</strong>触发事件时，一定时间内没有再触发事件，事件处理函数才会执行一次。</p>
<p>主要应用场景有：<strong>input验证、搜索联想、resize</strong>。</p>
<p>DEMO：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 防抖</span><br><span class="line">var debounce &#x3D; function(fn, wait)&#123;</span><br><span class="line">		var timeout &#x3D; null;</span><br><span class="line">		return function()&#123;</span><br><span class="line">				if(timeout !&#x3D;&#x3D; null)</span><br><span class="line">						clearTimeout(timeout);</span><br><span class="line">				timeout &#x3D; setTimeout(fn, wait);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理函数</span><br><span class="line">var handle &#x3D; function()&#123;</span><br><span class="line">		&#x2F;&#x2F;这里放的是相应事件的处理函数</span><br><span class="line">		console.log(Math.random());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加滚动监听事件</span><br><span class="line">window.addEventListener(&quot;scroll&quot;, debounce(handle, 1000));</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。</p>
<p>主要应用场景：</p>
<ul>
<li>鼠标不断点击触发，<code>mousedown</code>(单位时间内只触发一次)</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>
</ul>
<h4 id="方法一：事件戳"><a href="#方法一：事件戳" class="headerlink" title="方法一：事件戳"></a>方法一：事件戳</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var throttle &#x3D; function(func, delay) &#123;            </span><br><span class="line">		var prev &#x3D; Date.now();            </span><br><span class="line">		return function() &#123;                </span><br><span class="line">  			var context &#x3D; this;                </span><br><span class="line">				var args &#x3D; arguments;                </span><br><span class="line">				var now &#x3D; Date.now();                </span><br><span class="line">				if (now - prev &gt;&#x3D; delay) &#123;                    </span><br><span class="line">						func.apply(context, args);                    </span><br><span class="line">						prev &#x3D; Date.now();                </span><br><span class="line">    		&#125;            </span><br><span class="line">		&#125;        </span><br><span class="line">&#125;        </span><br><span class="line">function handle() &#123;            </span><br><span class="line">　　console.log(Math.random());        </span><br><span class="line">&#125;        </span><br><span class="line">window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</span><br></pre></td></tr></table></figure>

<h4 id="方法二：定时器"><a href="#方法二：定时器" class="headerlink" title="方法二：定时器"></a>方法二：定时器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var throttle &#x3D; function(func, delay)&#123;</span><br><span class="line">		var timeout &#x3D; null;</span><br><span class="line">		return function()&#123;</span><br><span class="line">				if(!timeout)&#123;</span><br><span class="line">						var context &#x3D; this;</span><br><span class="line">						var args &#x3D; arguments;</span><br><span class="line">						timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">								func.apply(context, args);</span><br><span class="line">								timeout &#x3D; null;</span><br><span class="line">						&#125;)</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">function handle() &#123;            </span><br><span class="line">　　console.log(Math.random());        </span><br><span class="line">&#125;        </span><br><span class="line">window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="数组扁平化处理"><a href="#数组扁平化处理" class="headerlink" title="数组扁平化处理"></a>数组扁平化处理</h3><h4 id="方法一：正则表达式"><a href="#方法一：正则表达式" class="headerlink" title="方法一：正则表达式"></a>方法一：正则表达式</h4><p>先将多维数组转换成字符串，再通过正则进行处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let num &#x3D; [1,5,[2,2],[3,[2,55],34],1];</span><br><span class="line">let str &#x3D; JSON.Stringify(num);</span><br><span class="line">&#x2F;&#x2F; 正则处理1</span><br><span class="line">result &#x3D; str.replace(&#x2F;(\[\])&#x2F;g, &#39;&#39;).split(&#39;,&#39;);</span><br><span class="line">&#x2F;&#x2F; 正则处理2</span><br><span class="line">str &#x3D; str.replace(&#x2F;(\[\])&#x2F;g, &#39;&#39;);</span><br><span class="line">str &#x3D; &#39;[&#39;+str+&#39;]&#39;;</span><br><span class="line">result2 &#x3D; JSON.parse(str);</span><br></pre></td></tr></table></figure>

<h4 id="方法二：拓展运算符"><a href="#方法二：拓展运算符" class="headerlink" title="方法二：拓展运算符"></a>方法二：拓展运算符</h4><blockquote>
<p>some( ) 方法用于检测数组中的元素是否满足指定条件（函数提供）。</p>
</blockquote>
<blockquote>
<p>… （拓展运算符）可以将数组元素迭代为函数参数使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (arr.some(Array.isArray)) &#123;</span><br><span class="line">  	arr &#x3D; [].concat(...arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法三：递归处理"><a href="#方法三：递归处理" class="headerlink" title="方法三：递归处理"></a>方法三：递归处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function myFlat(arr)&#123;</span><br><span class="line">		let result &#x3D; [];</span><br><span class="line">		if(Array.isArray(arr))&#123;</span><br><span class="line">				arr.forEach(function(item)&#123;</span><br><span class="line">						if(Array.isArray(item))&#123;</span><br><span class="line">								result.push(...myFlat(item));</span><br><span class="line">						&#125;else&#123;</span><br><span class="line">								result.push(item);</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>通过递归实现深拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj)&#123;</span><br><span class="line">		if(typeof obj !&#x3D;&#x3D; &#39;object&#39;) return false;</span><br><span class="line">		var newObj &#x3D; Array.isArray(obj)? []: &#123;&#125;;</span><br><span class="line">		for(var key in obj)&#123;</span><br><span class="line">				if(obj.hasOwnProperty(key))&#123;</span><br><span class="line">						if(typeof obj[key] &#x3D;&#x3D;&#x3D; &#39;object&#39;)&#123;</span><br><span class="line">								newObj[key] &#x3D; deepClone(obj[key]);</span><br><span class="line">						&#125;else&#123;</span><br><span class="line">								newObj[key] &#x3D; obj[key];</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Curry化"><a href="#Curry化" class="headerlink" title="Curry化"></a>Curry化</h3><blockquote>
<p>在数学和计算机科学中，柯里化是一种将<strong>使用多个参数的一个函数转换成一系列使用一个参数的函数</strong>的技术。</p>
</blockquote>
<h4 id="简单版curry函数实现"><a href="#简单版curry函数实现" class="headerlink" title="简单版curry函数实现"></a>简单版curry函数实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 简单版</span><br><span class="line">var curryV1 &#x3D; function(fn)&#123;</span><br><span class="line">		var args &#x3D; [].slice.call(arguments, 1);</span><br><span class="line">		return funciton()&#123;</span><br><span class="line">				var newArgs &#x3D; args.concat([].slice.call(arguments));</span><br><span class="line">				return fn.apply(this, newArgs);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="稍稍升级版"><a href="#稍稍升级版" class="headerlink" title="稍稍升级版"></a>稍稍升级版</h4><blockquote>
<p><code>slice(0)</code>的作用：</p>
<p>对原数组进行深拷贝</p>
<p>将类数组对象转化为真正的数组对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var curryV2 &#x3D; function(fn, args)&#123;</span><br><span class="line">		var len &#x3D; fn.length;</span><br><span class="line">		args &#x3D; args || [];</span><br><span class="line">		return function()&#123;</span><br><span class="line">				var _args &#x3D; args.slice(0), arg;</span><br><span class="line">				for(var i&#x3D;0; i&lt;arguments.length; i++)&#123;</span><br><span class="line">						arg &#x3D; arguments[i];</span><br><span class="line">						_args.push(arg);</span><br><span class="line">				&#125;</span><br><span class="line">				if(_args.length &lt; length)&#123;</span><br><span class="line">						return curryV2.call(this, fn, _args);</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">						return fn.apply(this, _args);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn &#x3D; curryV2(function(a, b, c) &#123;</span><br><span class="line">    console.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/03/JS%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xya Fred">
      <meta itemprop="description" content="Welcome to Natsun Blog~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Natsun Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/03/JS%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">JS继承</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-03 10:55:07 / 修改时间：14:49:59" itemprop="dateCreated datePublished" datetime="2020-04-03T10:55:07+08:00">2020-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h3><h4 id="使用子类的原型对象实现继承"><a href="#使用子类的原型对象实现继承" class="headerlink" title="使用子类的原型对象实现继承"></a>使用子类的原型对象实现继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明父类</span><br><span class="line">function SuperClass()&#123;</span><br><span class="line">	this.superValue &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 为父类添加共有方法</span><br><span class="line">SuperClass.prototype.getSuperValue &#x3D; function()&#123;</span><br><span class="line">	return this.superValue;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 声明子类</span><br><span class="line">function SubClass()&#123;</span><br><span class="line">	this.subValue &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 继承父类</span><br><span class="line">SubClass.prototype &#x3D; new SuperClass();</span><br><span class="line">&#x2F;&#x2F; 为子类添加共有方法</span><br><span class="line">SubClass.prototype.getSubValue &#x3D; function()&#123;</span><br><span class="line">	return this.subValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子类的使用实例</span><br><span class="line">var instance &#x3D; new SubClass()</span><br><span class="line">console.log(instance.getSuperValue());	&#x2F;&#x2F; true</span><br><span class="line">console.log(instance.getSubValue());		&#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>类的<strong>原型对象（prototype）</strong>的作用就是为类的原型添加共有方法，但类不能直接访问这些属性和方法，必须通过原型prototype访问。当我们实例化一个父类时，新创建的对象复制了父类的构造函数内的属性和方法并且将<code>__proto__</code>指向了父类的原型对象，这样就拥有了原型对象上的属性和方法。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>类式继承存在两个缺点：</p>
<ul>
<li><strong>多个子类的共有属性互相影响</strong>。由于子类通过其原型对象prototype对父类实例化，因此一个子类的实例更改子类原型从父类构造函数继承来得共有属性就会直接影响其他子类。</li>
<li>实例化父类时<strong>无法对父类构造函数中的属性进行初始化</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function SuperClass()&#123;</span><br><span class="line">		this.books &#x3D; [&#39;JS&#39;, &#39;CSS&#39;, &#39;HTML&#39;];</span><br><span class="line">&#125;</span><br><span class="line">function SubClass()&#123;&#125;</span><br><span class="line">SubClass.prototype &#x3D; new SuperClass();</span><br><span class="line">var instance1 &#x3D; new SubClass();</span><br><span class="line">var instance2 &#x3D; new SubClass();</span><br><span class="line">console.log(instance2.boosk)		&#x2F;&#x2F; [&#39;JS&#39;, &#39;CSS&#39;, &#39;HTML&#39;]</span><br><span class="line">instance1.books.push(&quot;设计模式&quot;)；</span><br><span class="line">console.log(instance2.boosk)		&#x2F;&#x2F; [&#39;JS&#39;, &#39;CSS&#39;, &#39;HTML&#39;, &#39;设计模式&#39;]</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><h4 id="使用call或apply实现继承"><a href="#使用call或apply实现继承" class="headerlink" title="使用call或apply实现继承"></a>使用call或apply实现继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明父类</span><br><span class="line">function SuperClass(id)&#123;</span><br><span class="line">    &#x2F;&#x2F; 引用类型共有属性</span><br><span class="line">    this.books &#x3D; [&#39;JS&#39;, &#39;CSS&#39;, &#39;HTML&#39;];</span><br><span class="line">    &#x2F;&#x2F; 值类型共有属性</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 父类声明原型方法</span><br><span class="line">SuperClass.prototype.showBooks &#x3D; function () &#123;</span><br><span class="line">    console.log(this.books);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 声明子类</span><br><span class="line">function SubClass(id) &#123;</span><br><span class="line">    &#x2F;&#x2F; 继承父类</span><br><span class="line">    SuperClass.call(this, id);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 创建两个不同的子类实例</span><br><span class="line">var instance1 &#x3D; new SubClass(10);</span><br><span class="line">var instance2 &#x3D; new SubClass(12);</span><br><span class="line"></span><br><span class="line">instance1.books.push(&quot;设计模式&quot;);   </span><br><span class="line">console.log(instance1.books);   &#x2F;&#x2F; [&#39;JS&#39;, &#39;CSS&#39;, &#39;HTML&#39;, &#39;设计模式&#39;]</span><br><span class="line">console.log(instance1.id);      &#x2F;&#x2F; 10</span><br><span class="line">console.log(instance2.books);   &#x2F;&#x2F; [&#39;JS&#39;, &#39;CSS&#39;, &#39;HTML&#39;]</span><br><span class="line">console.log(instance2.id);      &#x2F;&#x2F; 12</span><br><span class="line"></span><br><span class="line">instance1.showBooks();          &#x2F;&#x2F; TypeError</span><br></pre></td></tr></table></figure>

<p><code>SuperClass.call(this, id);</code>这条语句是构造函数式继承的精髓，由于这个方法可以<strong>更改函数的作用环境</strong>，因此在子类中调用该方法就是将子类的变量放在父类中执行一遍。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承，<strong>想要被子类所继承就必须放在构造函数中</strong>。这样创建出来的实例都会单独拥有一份而不能公用，违背了<strong>代码复用</strong>的原则</p>
<hr>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><h4 id="结合前两种方法优点的继承"><a href="#结合前两种方法优点的继承" class="headerlink" title="结合前两种方法优点的继承"></a>结合前两种方法优点的继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明父类</span><br><span class="line">function SuperClass(name)&#123;</span><br><span class="line">    &#x2F;&#x2F; 引用类型共有属性</span><br><span class="line">    this.books &#x3D; [&#39;JS&#39;, &#39;CSS&#39;, &#39;HTML&#39;];</span><br><span class="line">    &#x2F;&#x2F; 值类型共有属性</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 父类声明原型方法</span><br><span class="line">SuperClass.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 声明子类</span><br><span class="line">function SubClass(name, time) &#123;</span><br><span class="line">    &#x2F;&#x2F; 构造函数式继承父类name属性</span><br><span class="line">    SuperClass.call(this, name);</span><br><span class="line">    &#x2F;&#x2F; 子类新增共有属性</span><br><span class="line">    this.time &#x3D; time;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 类式继承 子类原型继承父类</span><br><span class="line">SubClass.prototype &#x3D; new SuperClass();</span><br><span class="line">&#x2F;&#x2F; 子类原型方法</span><br><span class="line">SuperClass.prototype.getTime &#x3D; function (time) &#123;</span><br><span class="line">    console.log(this.time);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>该方法在使用<strong>构造函数继承</strong>时执行了一遍父类的构造函数，而在实现<strong>子类原型的类式继承</strong>时又调用了一遍父类构造函数。因此<strong>父类构造函数调用了两遍</strong>，这不是最完美的方式。</p>
</li>
<li><p>子类SubClass不是父类SuperClass的实例，而子类的原型对象prototype才是</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(SubClass instanceof SuperClass);						&#x2F;&#x2F; false</span><br><span class="line">console.log(SubClass.prototype instanceof SuperClass);	&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><h4 id="对类式继承的封装"><a href="#对类式继承的封装" class="headerlink" title="对类式继承的封装"></a>对类式继承的封装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function inheritObject(o) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">		&#x2F;&#x2F; 过渡对象的原型继承父对象</span><br><span class="line">		F.prototype &#x3D; o;</span><br><span class="line">		&#x2F;&#x2F; 返回过渡对象的一个实例，该实例的原型继承了父对象</span><br><span class="line">		return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实质是对<strong>类式继承的一个封装</strong>，其中的过渡对象就相当于类式继承中的子类，只不过在原型式中作为一个过渡对象出现，目的是为了创建要返回的新的实例化对象。</p>
<p>F过渡类的构造函数中无内容，开销较小，使用起来较方便。如果感觉有必要把F过渡类缓存起来，不必要每次都创建一个新的过渡类，那就用<code>Object.create()</code>吧！</p>
<h4 id="类似的，使用Object-create-实现类式继承"><a href="#类似的，使用Object-create-实现类式继承" class="headerlink" title="类似的，使用Object.create()实现类式继承"></a>类似的，使用<code>Object.create()</code>实现类式继承</h4><blockquote>
<p>函数作用：创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明父类</span><br><span class="line">function SuperClass(name)&#123;</span><br><span class="line">		&#x2F;&#x2F; 引用类型共有属性</span><br><span class="line">		this.books &#x3D; [&#39;JS&#39;, &#39;CSS&#39;, &#39;HTML&#39;];</span><br><span class="line">		&#x2F;&#x2F; 值类型共有属性</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 声明子类</span><br><span class="line">function SubClass(name)&#123;</span><br><span class="line">		SuperClass.call(this, name);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子类继承父类</span><br><span class="line">SubClass.prototype &#x3D; Object.create(SuperClass.prototype);</span><br><span class="line">SubClass.prototype.constructor &#x3D; SubClass;</span><br></pre></td></tr></table></figure>

<h4 id="原型式继承的缺点"><a href="#原型式继承的缺点" class="headerlink" title="原型式继承的缺点"></a>原型式继承的缺点</h4><p>跟类式继承一样，由父类对象创建的子类对象也会复制父类对象的属性和方法，多个子类的共有属性会互相影响。</p>
<hr>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><h4 id="原型式继承的升级版"><a href="#原型式继承的升级版" class="headerlink" title="原型式继承的升级版"></a>原型式继承的升级版</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明基对象</span><br><span class="line">var book &#x3D; &#123;</span><br><span class="line">		name: &quot;js book&quot;,</span><br><span class="line">		alikeBook: [&quot;css book&quot;, &quot;html book&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">function createBook(obj)&#123;</span><br><span class="line">		&#x2F;&#x2F; 通过原型继承方式创建新对象</span><br><span class="line">		var o &#x3D; inheritObject(obj);</span><br><span class="line">		&#x2F;&#x2F; 拓展新对象</span><br><span class="line">		o.getName &#x3D; function()&#123;</span><br><span class="line">				console.log(this.name)</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 返回拓展后的对象</span><br><span class="line">		return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newBook &#x3D; createBook(book);</span><br><span class="line">newBook.getName();              &#x2F;&#x2F; js book</span><br><span class="line">console.log(newBook.alikeBook); &#x2F;&#x2F; [ &#39;css book&#39;, &#39;html book&#39; ]</span><br></pre></td></tr></table></figure>

<p>目标：<strong>增强新创建对象的继承思想</strong>。寄生式继承实质就是对原型继承的第二次封装，并且在第二次封装的过程中对继承的对象进行拓展，这样新创建的对象不仅有父类的属性和方法而且还添加了新的属性和方法。</p>
<hr>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><h4 id="寄生式-组合式强强联手"><a href="#寄生式-组合式强强联手" class="headerlink" title="寄生式 + 组合式强强联手"></a>寄生式 + 组合式强强联手</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 寄生式继承 继承原型</span><br><span class="line"> * 传递参数 subClass    子类</span><br><span class="line"> * 传递参数 superClass  父类</span><br><span class="line"> *&#x2F;</span><br><span class="line">function inhertPrototype(subClass, superClass) &#123;</span><br><span class="line">    &#x2F;&#x2F; 复制一份父类的原型副本保存到变量中</span><br><span class="line">    var p &#x3D; inheritObject(superClass.prototype)</span><br><span class="line">    &#x2F;&#x2F; 修正因为重写子类原型导致子类的constructor属性被修改</span><br><span class="line">    p.constructor &#x3D; subClass;</span><br><span class="line">    &#x2F;&#x2F; 设置子类的原型</span><br><span class="line">    subClass.prototype &#x3D; p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该继承方法与“组合继承”非常类似，只有一处地方做了修改：<strong>对子类原型的处理</strong>（子类原型<strong>继承父类原型不用执行构造函数</strong>，而是被赋予父类原型的一个引用）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DEMO:</span><br><span class="line">&#x2F;&#x2F; 声明父类</span><br><span class="line">function SuperClass(name)&#123;</span><br><span class="line">    &#x2F;&#x2F; 引用类型共有属性</span><br><span class="line">    this.color &#x3D; [&#39;Red&#39;, &#39;Green&#39;, &#39;Blue&#39;];</span><br><span class="line">    &#x2F;&#x2F; 值类型共有属性</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 父类声明原型方法</span><br><span class="line">SuperClass.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 声明子类</span><br><span class="line">function SubClass(name, time) &#123;</span><br><span class="line">    &#x2F;&#x2F; 构造函数式继承父类name属性</span><br><span class="line">    SuperClass.call(this, name);</span><br><span class="line">    &#x2F;&#x2F; 子类新增共有属性</span><br><span class="line">    this.time &#x3D; time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类式继承 子类原型继承父类 &#x3D;&gt; 寄生式继承父类原型</span><br><span class="line">&#x2F;&#x2F; SubClass.prototype &#x3D; new SuperClass();</span><br><span class="line">inheritPrototype(SubClass, SuperClass);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子类新增原型方法</span><br><span class="line">SuperClass.prototype.getTime &#x3D; function (time) &#123;</span><br><span class="line">    console.log(this.time);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xya Fred">
      <meta itemprop="description" content="Welcome to Natsun Blog~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Natsun Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">浏览器兼容问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-02 18:36:46 / 修改时间：22:13:23" itemprop="dateCreated datePublished" datetime="2020-04-02T18:36:46+08:00">2020-04-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="IE9以下的浏览器不支持forEach函数"><a href="#IE9以下的浏览器不支持forEach函数" class="headerlink" title="IE9以下的浏览器不支持forEach函数"></a>IE9以下的浏览器不支持<code>forEach</code>函数</h4><p><strong>解决方法</strong>：</p>
<p>加上下面这一段代码来支持这个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">if(!Array.prototype.forEach)&#123;</span><br><span class="line">	Array.prototype.forEach &#x3D; function(func)&#123;</span><br><span class="line">		var len &#x3D; this.length;</span><br><span class="line">		if(typeof func !&#x3D;&#x3D; &quot;function&quot;)</span><br><span class="line">			throw new TypeError();</span><br><span class="line">		var thisp &#x3D; arguments[1];</span><br><span class="line">		for(var i&#x3D;0; i&lt;len; i++)&#123;</span><br><span class="line">			if(i in this)&#123;</span><br><span class="line">				fun.call(thisp, this[i], i, this);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者这样：</span><br><span class="line">if (typeof Array.prototype.forEach !&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">  Array.prototype.forEach &#x3D; function(callback)&#123;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; this.length; i++)&#123;</span><br><span class="line">      callback.apply(this, [this[i], i, this]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/31/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xya Fred">
      <meta itemprop="description" content="Welcome to Natsun Blog~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Natsun Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/31/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">知识点记录</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-31 16:14:31" itemprop="dateCreated datePublished" datetime="2020-03-31T16:14:31+08:00">2020-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-05 19:20:34" itemprop="dateModified" datetime="2020-04-05T19:20:34+08:00">2020-04-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xya Fred"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Xya Fred</p>
  <div class="site-description" itemprop="description">Welcome to Natsun Blog~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xya Fred</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
</html>
